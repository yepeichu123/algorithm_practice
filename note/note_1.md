### 数据结构和算法

1. 数据结构的存储方式只有两种：数组（顺序存储）和链表（链式存储）
2. 数据结构的基本操作：遍历+访问，即增删查改
3. 框架就是套路，不论是增删查改，代码永远无法脱离结构．通过将结构作为大纲，根据具体问题在框架上添加代码就即可．
4. 数据结构是工具，算法是通过合适的工具解决特定问题的方法．那么在学习算法之前，就必须要了解常用的数据结构，了解它们的特性和缺陷．
5. 二叉树是最容易培养框架思维的，而且大部分算法技巧，本质上都是树的遍历问题．

链表：
class TreeNode {
    int val;
    TreeNode next;
};

二叉树：
class TreeNode {
    int val;
    TreeNode left, right;
};

N叉树：
class TreeNode {
    int val;
    TreeNode[] children;
};
    
6. 上述结构本质上是一样的，都是从链表出发，进行丰富．


### 动态规划

7. 动态规划的一般形式就是求最值，求解动态规划的核心问题是穷举．（求最值就需要把所有可行的答案穷举出来，然后在其中找最值）
8. 动态规划包含三要素：重叠子问题，最优子结构和状态转移方程．
9.  动态规划的解决方法有：暴力递归，带备忘录的递归解法和dp数组的迭代解法．
10. 计算机解决问题没有任何奇迹淫巧，它唯一的解决办法就是穷举，穷举所有可能性．算法设计无非就是思考如何穷举，然后再追求如何聪明的穷举．
11. 最优子结构性质作为动态规划问题的必要条件，一定是求最值的．

### 回溯算法

12. 回溯算法实际上就是一个决策树的遍历过程．
13. 回溯算法需要思考的三个问题主要是：路径（已经做出的选择），选择列表（当前可以做的选择），结束条件（到达决策树底层，无法再做选择的条件）．
14. 回溯算法的框架：
    result = []
    def backtrack(路径, 选择列表):
        if 满足结束条件:
            result.add(路径)
            return
        
        for 选择 in 选择列表:
            做选择
            backtrack(路径, 选择列表)
            撤销选择
    核心就是for循环里面的递归，在递归调用之前［做选择］，在递归调用之后［撤销选择］．
15. 无论怎么优化，都符合回溯框架，并且时间复杂度不可能低于 $O(N!)$，因为穷举整颗决策树是无法避免的，这是回溯算法的一个特点，不像动态规划存在重叠子问题可以优化，回溯算法就是纯暴力穷举，复杂度一般都很高．
16. 写 backtrack 函数时，需要维护走过的「路径」和当前可以做的「选择列表」，当触发「结束条件」时，将「路径」记入结果集．
17. 某种程度上说，动态规划的暴力求解阶段就是回溯算法．只是有的问题具有重叠子问题性质，可以用dp table或者备忘录优化，将递归树大幅剪枝，这就变成了动态规划．

### 二分法

18. 二分法算法框架：
    int binarySearch(int[] nums, int target) {
        int left = 0, right = ...;

        while(...) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                ...
            } else if (nums[mid] < target) {
                left = ...
            } else if (nums[mid] > target) {
                right = ...
            }
        }
        return ...;
    }
19. 分析二分查找的一个技巧是：不要出现else，而是把所有情况用else if写清楚，这样可以清楚地展现所有细节．
20. 边界条件，防止溢出：比如left + (right - left)/2 和　(left + right)/2结果一致，但是前者可以防止相加时溢出．
21. 二分法三种逻辑操作方法：
    > a. 第一个，最基本的二分查找算法：
        因为我们初始化 right = nums.length - 1
        所以决定了我们的「搜索区间」是 [left, right]
        所以决定了 while (left <= right)
        同时也决定了 left = mid+1 和 right = mid-1

        因为我们只需找到一个 target 的索引即可
        所以当 nums[mid] == target 时可以立即返回
    
    > b. 第二个，寻找左侧边界的二分查找：
        因为我们初始化 right = nums.length
        所以决定了我们的「搜索区间」是 [left, right)
        所以决定了 while (left < right)
        同时也决定了 left = mid + 1 和 right = mid

        因为我们需找到 target 的最左侧索引
        所以当 nums[mid] == target 时不要立即返回
        而要收紧右侧边界以锁定左侧边界

    > c.　第三个，寻找右侧边界的二分查找：
        因为我们初始化 right = nums.length
        所以决定了我们的「搜索区间」是 [left, right)
        所以决定了 while (left < right)
        同时也决定了 left = mid + 1 和 right = mid

        因为我们需找到 target 的最右侧索引
        所以当 nums[mid] == target 时不要立即返回
        而要收紧左侧边界以锁定右侧边界

        又因为收紧左侧边界时必须 left = mid + 1
        所以最后无论返回 left 还是 right，必须减一

22. 二分法注意［搜索区间］和while的终止条件，如果存在漏掉的元素，记得在最后检查．
23. 二分法查找在实际问题中的应用：
    for (int i = 0; i < n; i++)
        if (isOK(i))
            return ans;
    在遍历问题中，二分法就可以应用．

### 滑动窗口

24. 滑动窗口的抽象思想：
     int left = 0, right = 0;
    while (right < s.size()) {
        window.add(s[right]);
        right++;
        
        while (valid) {
            window.remove(s[left]);
            left++;
        }
    }

